"""
lintquarto: Lint Python code embedded in Quarto (.qmd) files.

Acknowledgements
----------------
Some parts of this module were generated by and adapted from Perplexity.
"""

import subprocess
import sys
from pathlib import Path

from .args import CustomArgumentParser
from .converter import convert_qmd_to_py
from .linters import Linters


def process_qmd(
    qmd_file, linter, keep_temp_files=False, verbose=False
):
    """
    Convert a .qmd file to .py, lint it, and clean up.

    Parameters
    ----------
    qmd_file : str or Path
        Path to the input .qmd file.
    linter : str
        Name of the linter to use (pylint, flake8, mypy).
    keep_temp_files : bool, optional
        If True, retain the temporary .py file after linting.
    verbose : bool, optional
        If True, print detailed progress information.

    Returns
    -------
    int
        0 on success, nonzero on error.

    Notes
    -----
    Adapted from code generated by Perplexity.
    """
    # Convert input to Path object
    qmd_path = Path(qmd_file)

    # Validate that the file exists and has a .qmd extension
    if not qmd_path.exists() or qmd_path.suffix != ".qmd":
        print(f"Error: {qmd_file} is not a valid .qmd file.", file=sys.stderr)
        return 1

    # Check if linter is supported by lintquarto and available on user's system
    # Uses return codes 0 & 1 for CLI/shell compatability, as will be run
    # from the command line
    linters = Linters()
    try:
        linters.check_supported(linter)
        linters.check_available(linter)
    except (ValueError, FileNotFoundError) as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1

    # Convert the .qmd file to a .py file
    try:
        py_file = convert_qmd_to_py(
            qmd_path=str(qmd_path), linter=linter, verbose=verbose)
        if py_file is None:
            print(f"Error: Failed to convert {qmd_file} to .py",
                  file=sys.stderr)
            return 1
    # Intentional broad catch for unknown conversion errors
    # pylint: disable=broad-except
    except Exception as e:
        print(f"Error: Failed to convert {qmd_file} to .py: {e}",
              file=sys.stderr)
        return 1

    # Determine base name and remove leading "./"
    nodot_base = str(qmd_path.with_suffix(""))
    if nodot_base.startswith("./"):
        nodot_base = nodot_base[2:]

    # Run linter on the temporary .py file and capture output
    command = linters.supported[linter] + [str(py_file)]
    result = subprocess.run(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=False
    )

    # Replace references to the .py file with the .qmd file and print output
    output = result.stdout.replace(f"{nodot_base}.py", qmd_file)
    print(output, end="")
    if result.stderr:
        print(result.stderr, file=sys.stderr)

    # Remove temporary .py file unless keep_temp_files is set
    if not keep_temp_files:
        try:
            py_file.unlink()
        # Broad catch ensures cleanup warnings don't crash process
        # pylint: disable=broad-except
        except Exception as e:
            print(f"Warning: Could not remove temporary file {py_file}: {e}",
                  file=sys.stderr)
    return 0


def gather_qmd_files(paths, exclude=None):
    """
    Gather all .qmd files from a list of files and directories, excluding
    specified paths.

    Parameters
    ----------
    paths : list of str or Path
        List of file or directory paths.
    exclude : list of str or Path, optional
        List of files or directories to exclude.

    Returns
    -------
    list of str
        List of .qmd file paths found, excluding those in `exclude`.

    Notes
    -----
    Adapted from code generated by Perplexity.
    """
    exclude = set(str(Path(e).resolve()) for e in (exclude or []))
    files = []
    for path in paths:
        p = Path(path)
        # If path is a single .qmd file, add it
        if p.is_file() and p.suffix == ".qmd":
            abs_file = str(p.resolve())
            # Exclude if file or its parent dir is in exclude
            if not any(abs_file == e or abs_file.startswith(e + "/")
                       for e in exclude):
                files.append(str(p))
        # If path is a directory, recursively add all .qmd files found within
        elif p.is_dir():
            for f in p.rglob("*.qmd"):
                abs_file = str(f.resolve())
                if not any(abs_file == e or abs_file.startswith(e + "/")
                           for e in exclude):
                    files.append(str(f))
    return files


def main():
    """
    Entry point for the lintquarto CLI.

    Parses arguments, processes .qmd files, and exits with appropriate status
    code.

    Notes
    -----
    Adapted from code generated by Perplexity.
    """
    # Set up custom argumentparser with help statements
    parser = CustomArgumentParser(
        description="Lint Python code in Quarto (.qmd) files."
    )
    parser.add_argument(
        "linter", choices=list(Linters().supported.keys()),
        help="Linter to use."
    )
    parser.add_argument(
        "paths", nargs="+",
        help="One or more .qmd files or directories to lint."
    )
    parser.add_argument(
        "-e", "--exclude", type=str, default="", metavar="[exclude_paths]",
        help=("Comma-separated list of files and/or directories to exclude " +
              "from linting.")
    )
    parser.add_argument(
        "-v", "--verbose", action="store_true",
        help="Verbose output."
    )
    parser.add_argument(
        "-k", "--keep-temp", action="store_true",
        help="Keep temporary .py files after linting."
    )
    args = parser.parse_args()

    # Gather all .qmd files from the provided arguments
    exclude_list = [e.strip() for e in args.exclude.split(",") if e.strip()]
    qmd_files = gather_qmd_files(args.paths, exclude=exclude_list)
    if not qmd_files:
        print(f"No .qmd files found in {args.paths}.", file=sys.stderr)
        sys.exit(1)

    exit_code = 0
    # Process each .qmd file found
    for qmd_file in qmd_files:
        ret = process_qmd(qmd_file=qmd_file,
                          linter=args.linter,
                          keep_temp_files=args.keep_temp,
                          verbose=args.verbose)
        if ret != 0:
            exit_code = ret
    sys.exit(exit_code)


if __name__ == "__main__":
    # Run the main function if this module is executed as a script
    main()
