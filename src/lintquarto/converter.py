"""
Convert .qmd file to python file.

Acknowledgements
----------------
Some parts of this module were generated by and adapted from Perplexity.
"""

from pathlib import Path
import re
import warnings

from .args import CustomArgumentParser


class QmdToPyConverter:
    """
    Convert lines from a .qmd file to .py file.

    1. Preserve line alignment.
    2. Amend Quarto code chunk options ("#| " to "# |") to prevent lint errors,
    with handling for leading indentation and blank lines at cell start.

    Attributes
    ----------
    py_lines : list
        Stores the lines to be written to the output Python file.
    in_python : boolean
        True if currently processing lines inside a Python code chunk.
    in_chunk_options : boolean
        True if currently at the start of a code chunk, parsing Quarto chunk
        options or leading blank lines.

    Notes
    -----
    Adapted from code generated by Perplexity.
    """
    def __init__(self):
        """
        Set-up the class.
        """
        self.py_lines = []
        self.in_python = False
        self.in_chunk_options = False
        self.reset()

    def reset(self):
        """
        Reset the state.
        """
        self.py_lines = []
        self.in_python = False
        self.in_chunk_options = False

    def convert(self, qmd_lines):
        """
        Run converter on the provided lines.

        Parameters
        ----------
        qmd_lines : list
            List containing each line from the Quarto file.

        Returns
        -------
        py_lines : list
            List of each line for the output Python file.
        """
        self.reset()
        for original_line in qmd_lines:
            self.process_line(original_line)
        return self.py_lines

    def process_line(self, original_line):
        """
        Process individual lines with state tracking.

        Parameters
        ----------
        original_line : str
            Line to process.
        """
        # Remove the trailing new line
        line = original_line.rstrip("\n")

        # Check if it is the start of a python code chunk
        if re.match(r"^```\{python\}", line):
            self.in_python = True
            self.in_chunk_options = True
            self.py_lines.append("# %% [python]")

        # Check if it is the end of a code chunk
        elif line.strip() == "```":
            self.in_python = False
            self.in_chunk_options = False
            self.py_lines.append("# -")

        # Check if it is within a python code chunk
        elif self.in_python:
            self._handle_python_chunk(line)

        # For all other lines, set to # -
        else:
            self.py_lines.append("# -")

    def _handle_python_chunk(self, line):
        """
        Process a line within a Python code chunk.

        - Handles Quarto chunk options (lines starting with '#| '), converting
        them to '# |'.
        - Skips blank lines at the start of the chunk.
        - For the first actual code line after options/blanks:
            - Appends '# noqa: E305' to suppress false positives for missing
            blank lines after previous cell's function/class.
            - If the line starts with 'def' or 'class', also appends
            '# noqa: E302' to suppress false positives for missing blank lines
            before a function/class.
        - All subsequent lines are appended unchanged.

        Parameters
        ----------
        line : str
            The line to process.
        """
        if self.in_chunk_options:
            # If line is blank, just append it and keep looking for options
            if line.strip() == "":
                self.py_lines.append(line)
            else:
                # Strip any blank spaces from start of line
                stripped = line.lstrip()
                # Convert Quarto chunk option to '# |', preserving indentation
                if stripped.startswith("#| "):
                    indent = line[:len(line) - len(stripped)]
                    modified_line = indent + "# |" + stripped[3:]
                    self.py_lines.append(modified_line)
                else:
                    # First code line after options/blanks:
                    # Always append '# noqa: E305' (never a real E305 here)
                    # If it's a function/class definition, also append
                    # '# noqa: E302'
                    if re.match(r"^(def|class)\b", stripped):
                        line = f"{line}  # noqa: E302,E305"
                    else:
                        line = f"{line}  # noqa: E305"
                    self.py_lines.append(line)
                    self.in_chunk_options = False
        else:
            # After the first code line, append all lines unchanged
            self.py_lines.append(line)


def convert_qmd_to_py(qmd_path, output_path=None, verbose=False):
    """
    Convert a Quarto (.qmd) file to Python (.py) file, preserving line
    alignment.

    Parameters
    ----------
    qmd_path : str or Path
        Path to the input .qmd file.
    output_path : str or Path, optional
        Path for the output .py file. If None, uses qmd_path with .py suffix.
    verbose : bool, optional
        If True, print detailed progress information.

    Examples
    --------
    >>> convert_qmd_to_py("input.qmd", "output.py", True)
    # To use from the command line:
    # $ python converter.py input.qmd [output.py] [-v]

    Notes
    -----
    Adapted from code generated by Perplexity.
    """
    # Convert input path to a Path object
    qmd_path = Path(qmd_path)

    # Set up converter
    converter = QmdToPyConverter()

    # Determine output path. If provided, convert to a Path object. If not,
    # the file extension of the input file to `.py`
    if output_path is None:
        output_path = qmd_path.with_suffix(".py")
    else:
        output_path = Path(output_path)

    if verbose:
        print(f"Converting {qmd_path} to {output_path}")

    try:
        # Open and read the QMD file, storing all lines in qmd_lines
        with open(qmd_path, "r", encoding="utf-8") as f:
            qmd_lines = f.readlines()

        # Iterate over lines, keeping python code, and setting rest to "# -"
        py_lines = converter.convert(qmd_lines=qmd_lines)

        # Write the output file
        with open(output_path, "w", encoding="utf-8") as f:
            f.write("\n".join(py_lines) + "\n")

        if verbose:
            print(f"✓ Successfully converted {qmd_path} to {output_path}")

        # Check that line counts match
        qmd_len = len(qmd_lines)
        py_len = len(py_lines)
        if qmd_len == py_len:
            if verbose:
                print(f"  Line count: {qmd_len} → {py_len} ")
        else:
            warnings.warn(f"Line count mismatch: {qmd_len} → {py_len}",
                          RuntimeWarning)

    # Error messages if issues finding/accessing files, or otherwise.
    except FileNotFoundError:
        print(f"Error: Input file '{qmd_path}' not found")
    except PermissionError:
        print(f"Error: Permission denied accessing '{qmd_path}' " +
              f"or '{output_path}'")
    # Intentional broad catch for unexpected conversion errors
    # pylint: disable=broad-except
    except Exception as e:
        print(f"Error during conversion: {e}")


# To ensure it executes if run from terminal:
if __name__ == "__main__":

    # Set up argument parser with help statements
    parser = CustomArgumentParser(
        description="Convert .qmd file to python file.")
    parser.add_argument("qmd_path", help="Path to the input .qmd file.")
    parser.add_argument("output_path", nargs="?", default=None,
                        help="(Optional) path to the output .py file.")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Print detailed progress information.")
    args = parser.parse_args()

    # Pass arguments to function and run it
    convert_qmd_to_py(args.qmd_path, args.output_path, args.verbose)
