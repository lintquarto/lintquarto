"""
Unit tests for the __main__ module.

Acknowledgements
----------------
Some parts of these tests were generated by and adapted from Perplexity.
"""

from unittest.mock import MagicMock
from pathlib import Path

import pytest

from lintquarto.__main__ import process_qmd, gather_qmd_files, main


# =============================================================================
# Fixtures ("dummy" objects to be used in tests)
# =============================================================================

@pytest.fixture
def dummy_path():
    """Fixture: Returns a MagicMock Path object simulating a .qmd file."""

    # Create a mock object, with `spec=Path` ensuring it only allows attributes
    # and methods that a real Path object would have.
    path = MagicMock(spec=Path)

    # Configures the mock so path.exists() will always return True
    path.exists.return_value = True

    # Sets the suffix to `.qmd` so it looks like a Quarto markdown file
    path.suffix = ".qmd"

    # In real code, with_suffix is a method of Path that returns a new path
    # with a different file extension. This configures it so it returns the
    # same mock object (path) instead of creating a new one
    path.with_suffix.return_value = path

    # Configures the mock so str(path) returns "dummy.qmd"
    path.__str__.return_value = "dummy.qmd"

    return path


@pytest.fixture
def dummy_pyfile():
    """Fixture: Returns a MagicMock Path object simulating a .py file."""

    # Create a mock object, with `spec=Path` ensuring it only allows attributes
    # and methods that a real Path object would have.
    pyfile = MagicMock(spec=Path)

    # Configures the mock so str(path) returns "dummy.py"
    pyfile.__str__.return_value = "dummy.py"

    # Sets the unlink method (which deletes a file in real Path objects) to be
    # another Mock (so it doesn't actually delete files)
    pyfile.unlink = MagicMock()

    return pyfile


@pytest.fixture
def dummy_linters():
    """Fixture: Returns a MagicMock linters object with supported linters."""
    # Create a mock object with an attribute "supported" containing a dict
    linters = MagicMock()
    linters.supported = {"flake8": ["flake8"]}
    return linters


# =============================================================================
# 1. process_qmd(): file and linter validation
# =============================================================================

@pytest.mark.parametrize(
    "exists,suffix", [
        (False, ".qmd"),
        (True, ".txt"),
        (False, ".txt"),
    ]
)
def test_process_qmd_invalid_file(
    # pylint: disable=redefined-outer-name
    monkeypatch, exists, suffix, dummy_path
):
    """Test that invalid files (wrong extension or missing) return error."""

    # Set up the dummy_path mock to simulate a file's existence and file
    # extension for this test case
    dummy_path.exists.return_value = exists
    dummy_path.suffix = suffix

    # Replace the Path class in __main__ with a lambda returning dummy_path, so
    # any code in process_qmd that tries to create a Path object will get mock
    monkeypatch.setattr("lintquarto.__main__.Path", lambda _: dummy_path)

    # Disable printing by replacing print function with a no-op
    monkeypatch.setattr("builtins.print", lambda *_, **__: None)

    # Call the process_qmd function with the test file and linter name, and
    # checked that it returns an error (1)
    assert process_qmd("dummy.qmd", "pylint") == 1


@pytest.mark.parametrize("linter,exception", [
    ("not_a_linter", ValueError),
    ("flake8", FileNotFoundError),
])
def test_process_qmd_linter_errors(
    # pylint: disable=redefined-outer-name
    monkeypatch, linter, exception, dummy_path, dummy_linters
):
    """Test process_qmd returns error for unsupported or unavailable linter."""
    dummy_path.suffix = ".qmd"
    dummy_path.exists.return_value = True

    # Simulate linter checks raising exceptions
    def check_supported(linter_name):
        if exception is ValueError:
            raise ValueError("unsupported")

    def check_available(linter_name):
        if exception is FileNotFoundError:
            raise FileNotFoundError("not found")

    dummy_linters.check_supported.side_effect = check_supported
    dummy_linters.check_available.side_effect = check_available

    # Patch dependencies
    monkeypatch.setattr("lintquarto.__main__.Path", lambda x: dummy_path)
    monkeypatch.setattr("lintquarto.__main__.Linters", lambda: dummy_linters)
    monkeypatch.setattr("builtins.print", lambda *a, **k: None)
    assert process_qmd("dummy.qmd", linter) == 1


# =============================================================================
# 2. process_qmd(): conversion and linting execution
# =============================================================================

def test_process_qmd_conversion_failure(
    monkeypatch, dummy_path, dummy_linters
):
    """Test process_qmd returns error if conversion fails or raises."""
    # Patch Path, Linters, and print
    monkeypatch.setattr("lintquarto.__main__.Path", lambda x: dummy_path)
    monkeypatch.setattr("lintquarto.__main__.Linters", lambda: dummy_linters)
    monkeypatch.setattr("builtins.print", lambda *a, **k: None)
    # Simulate convert_qmd_to_py returning None
    monkeypatch.setattr("lintquarto.__main__.convert_qmd_to_py",
                        lambda **kwargs: None)
    assert process_qmd("dummy.qmd", "flake8") == 1
    # Simulate convert_qmd_to_py raising an exception
    monkeypatch.setattr(
        "lintquarto.__main__.convert_qmd_to_py",
        lambda **kwargs: (_ for _ in ()).throw(Exception("fail"))
    )
    assert process_qmd("dummy.qmd", "flake8") == 1


def test_process_qmd_success(
    monkeypatch, dummy_path, dummy_pyfile, dummy_linters, capsys
):
    """Test process_qmd runs linter and prints output on success."""
    # Patch Path, Linters, and conversion
    monkeypatch.setattr("lintquarto.__main__.Path", lambda x: dummy_path)
    monkeypatch.setattr("lintquarto.__main__.Linters", lambda: dummy_linters)
    monkeypatch.setattr("lintquarto.__main__.convert_qmd_to_py",
                        lambda **_: dummy_pyfile)
    # Simulate linter subprocess result
    dummy_result = MagicMock(stdout="dummy.py:1: error\n", stderr="")
    monkeypatch.setattr("lintquarto.__main__.subprocess.run",
                        lambda *_, **__: dummy_result)
    # Run the function and capture output
    assert process_qmd("dummy.qmd", "flake8") == 0
    captured = capsys.readouterr()
    assert "dummy.qmd:1: error\n" in captured.out


# =============================================================================
# 3. gather_qmd_files()
# =============================================================================

@pytest.mark.parametrize(
    "paths,exclude,expected",
    [
        (["a.qmd"], [], ["a.qmd"]),
        (["a.qmd"], ["a.qmd"], []),
        (["dir"], [], ["dir/file1.qmd", "dir/file2.qmd"]),
        (["dir"], ["dir"], []),
    ]
)
def test_gather_qmd_files(monkeypatch, paths, exclude, expected):
    """Test gather_qmd_files returns correct .qmd files, respecting exclude."""
    # Dummy Path to simulate files and directories
    def DummyPath(name):
        path = MagicMock(spec=Path)
        path.name = name
        path.suffix = ".qmd" if name.endswith(".qmd") else ""
        path.is_file.return_value = name.endswith(".qmd")
        path.is_dir.return_value = name == "dir"
        path.resolve.return_value = Path(name)
        path.rglob.return_value = [Path("dir/file1.qmd"),
                                   Path("dir/file2.qmd")]
        path.__str__.return_value = name
        return path
    monkeypatch.setattr("lintquarto.__main__.Path", DummyPath)
    result = gather_qmd_files(paths, exclude)
    assert set(result) == set(expected)


def test_gather_qmd_files_exclude_subdir(monkeypatch):
    """Test gather_qmd_files excludes .qmd files in excluded subdirectories."""
    def DummyPath(name):
        path = MagicMock(spec=Path)
        path.name = name
        path.suffix = ".qmd" if name.endswith(".qmd") else ""
        path.is_file.return_value = False
        path.is_dir.return_value = True
        path.resolve.return_value = Path(name)
        path.rglob.return_value = [Path("dir/exclude/file.qmd"),
                                   Path("dir/keep/file.qmd")]
        path.__str__.return_value = name
        return path
    monkeypatch.setattr("lintquarto.__main__.Path", DummyPath)
    result = gather_qmd_files(["dir"], ["dir/exclude"])
    assert result == ["dir/keep/file.qmd"]


# =============================================================================
# 4. main()
# =============================================================================

def test_main_no_qmd_files(monkeypatch):
    """Test main exits with error if no .qmd files found."""

    class DummyArgs:
        linter = "flake8"
        paths = ["nofiles"]
        exclude = ""
        verbose = False
        keep_temp = False

    class DummyParser:
        def __init__(self, **_):
            pass

        def add_argument(self, *_, **__):
            pass

        def parse_args(self):
            return DummyArgs()

    # Patch parser, gather_qmd_files, sys.exit, and print
    monkeypatch.setattr("lintquarto.__main__.CustomArgumentParser",
                        lambda **_: DummyParser())
    monkeypatch.setattr("lintquarto.__main__.gather_qmd_files",
                        lambda _, exclude=None: [])
    monkeypatch.setattr("sys.exit",
                        lambda code: (_ for _ in ()).throw(SystemExit(code)))
    monkeypatch.setattr("builtins.print", lambda *_, **__: None)
    with pytest.raises(SystemExit) as exc:
        main()
    assert exc.value.code == 1


def test_main_success(monkeypatch):
    """Test main exits with success if .qmd files are processed."""
    class DummyArgs:
        linter = "flake8"
        paths = ["a.qmd"]
        exclude = ""
        verbose = False
        keep_temp = False

    class DummyParser:
        def __init__(self, **_):
            pass

        def add_argument(self, *_, **__):
            pass

        def parse_args(self):
            return DummyArgs()

    # Patch parser, gather_qmd_files, process_qmd, and sys.exit
    monkeypatch.setattr("lintquarto.__main__.CustomArgumentParser",
                        lambda **_: DummyParser())
    monkeypatch.setattr("lintquarto.__main__.gather_qmd_files",
                        lambda _, exclude=None: ["a.qmd"])
    monkeypatch.setattr("lintquarto.__main__.process_qmd", lambda **_: 0)
    monkeypatch.setattr("sys.exit",
                        lambda code: (_ for _ in ()).throw(SystemExit(code)))
    with pytest.raises(SystemExit) as exc:
        main()
    assert exc.value.code == 0
